// Метод filter()
// Метод filter(callback) используется для единственной
// операции - фильтрации массива, то есть когда необходимо выбрать
// более одного элемента из коллекции по какому - то критерию.

// массив.filter((Element, index, array) {
// // Тело коллбек-функции
// });

// // - Не изменяет оригинальный массив.
// // - Поэлементно перебирает оригинальный массив.
// // - Возвращает новый массив.
// // - Добавляет в возвращаемый массив элементы которые удовлетворяют условию коллбек-функции.
// // - Если коллбек вернул true элемент добавляется в возвращаемый массив.
// // - Если коллбек вернул false элемент не добавляется в возвращаемый массив.
// // - Если ни один элемент не удовлетворил условию, возвращает пустой массив.

// // const values = [51, -3, 27, 21, -68, 42, -37];

// // const positiveValues = values.filter(value => value >= 0);
// // console.log(positiveValues); // [51, 27, 21, 42]

// // const negativeValues = values.filter(value => value < 0);
// // console.log(negativeValues); // [-3, -68, -37]

// // const bigValues = values.filter(value => value > 1000);
// // console.log(bigValues); // []

// // // Оригинальный массив не изменился
// // console.log(values); // [51, -3, 27, 21, -68, 42, -37]

// // То есть метод filter вызывает коллбек - функцию для каждого элемента
// // исходного массива и если результат её выполнения true, текущий элемент
// // добавляет в новый массив.

// // =============================================
// // Фильтрация уникальных элементов
// // Используя метод filter() можно выполнить фильтрацию массива так, что в
// // нём останутся только уникальные элементы.Этот приём работает только с
// // массивом примитивных значений - не объектов.

// // Вернёмся к группе студентов и массиву всех посещаемых предметов, которые мы
// //  получили методом flatMap().

// // const students = [
// //   { name: "Манго", courses: ["математика", "физика"] },
// //   { name: "Поли", courses: ["информатика", "математика"] },
// //   { name: "Киви", courses: ["физика", "биология"] },
// // ];

// // const allCourses = students.flatMap(student => student.courses);
// // ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];

// // В переменной allCourses хранится массив всех посещаемых предметов,
// // которые могут повторяться.Задача заключается в том, чтобы сделать
// // новый массив, в котором будут только уникальные предметы, то есть
// // без повторений.

// // const uniqueCourses = allCourses.filter(
// //   (course, index, array) => array.indexOf(course) === index
// // );
// // console.log(allCourses);
// // # Массив всех курсов
// // ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];

// // Используя array.indexOf(course) выполняем поиск первого совпадения
// // текущего элемента course и получаем его индекс в оригинальном массиве
// // всех курсов.В параметре index хранится индекс текущего элемента course
// // при переборе массива методом filter.

// // Если результат indexOf() и значение index равны - это уникальный элемент,
// // потому что это первый раз когда такое значение встречается в массиве
// // и на текущей итерации фильтр обрабатывает именно его.

// // # Массив всех курсов
// // ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];
// // Для элемента 'математика' под индексом 0:

// // indexOf() вернёт 0, потому что ищет первое совпадение.
// // Значение параметра index будет 0.
// // Они равны, значит это уникальный элемент.
// // Для элемента 'математика' под индексом 3:

// // indexOf() вернёт 0, потому что ищет первое совпадение.
// // Значение параметра index будет 3.
// // Они не равны, значит это повторяющийся - не уникальный элемент.

// // =====================================================================
// // Массив объектов
// // При работе с массивом объектов выполняется фильтрация по значению
// // какого - то свойства.В результате получается новый массив отфильтрованных
// // объектов.

// // Например, есть массив студентов с баллами за тест.Необходимо
// // отфильтровать лучших(балл выше 80), худших(балл ниже 50) и средних
// // студентов(балл от 50 до 80).

// const LOW_SCORE = 50;
// const HIGHT_SCORE = 80;
// const students = [
//     { name: "Манго", score: 83 },
//     { name: "Поли", score: 59 },
//     { name: "Аякс", score: 37 },
//     { name: "Киви", score: 94 },
//     { name: "Хьюстон", score: 64 },
// ];

// const best = students.filter(student => student.score >= HIGHT_SCORE);
// console.log(best);// Массив объектов с именами Манго и Киви

// const worst = students.filter(student => student.score < LOW_SCORE);
// console.log(worst);// Массив с одним объектом Аякс

// // В коллбек-функции удобно деструктуризировать свойства объекта

// const average = students.filter(
//     ({ score }) => score >= LOW_SCORE && score < HIGHT_SCORE
// );

// console.log(average);// Массив объектов с именами Поли и Хьюстон




