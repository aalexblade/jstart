// ; Правила определения this

// ; Необходимо усвоить всего одно правило для определения
// ; this - значение контекста внутри функции (не стрелочной) определятся
// ; не в момент ее создания, а в момент вызова. То есть значение this
// ; определяется тем, как вызывается функция, а не где она была объявлена.

// ; this в глобальной области видимости

// ; В глобальной области видимости, если скрипт выполняется не в строгом
// ; режиме, this ссылается на объект window. В строгом режиме значение this,
// ; в глобальной области видимости, будет undefined.

// function foo() {
//     console.log(this);
// // };

// // foo();  //window без "use strict" и undefined с "use strict"

// // ================================================================
// // this в методе объекта

// // Если функция была вызвана как метод объекта, то контекст будет ссылаться
// //  на объект, частью которого является метод.

// // const petya = {
// //     username: "Petya",
// //     showThis() {
// //         console.log(this);
// //     },
// //     showeName() {
// //         console.log(this.username);
// //     },
// // };

// // // petya.showThis();
// // petya.showeName();

// // Разберем более сложный пример для лучшего понимания.

// // -Сначала создадим функцию в глобальной области видимости и вызовем ее.
// // -После чего присвоим ее в свойство объекта и вызовем как метод этого
// // объекта.

// function showThis() {
//   console.log("this in showThis: ", this);
// }

// // Вызываем в глобальном контексте
// showThis(); // this in showThis: Window

// const user = {
//   username: "Mango",
// };

// // Записываем ссылку на функцию в свойство объекта
// // Обратите внимание, что это не вызов - нет ()
// user.showContext = showThis;

// // Вызываем функцию в контексте объекта
// // this будет указывать на текущий объект, в контексте
// // которого осуществляется вызов, а не на глобальный объект.
// user.showContext(); // this in showThis: {username: "Mango", showContext: ƒ}

// ====================================================================
// this в callback-функциях

// При передаче методов объекта как колбэк - функций, контекст не сохраняется.
// Колбэк это ссылка на метод, которая присваивается как значение параметра,
// вызываемого без объекта.

// const customer = {
//   firstName: "Jacob",
//   lastName: "Mercer",
//   getFullName() {
//     return `${this.firstName} ${this.lastName}`;
//   },
// };

// function makeMessage(callback) {
//   // callback() это вызов метода getFullName без объекта
//   console.log(`Обрабатываем заявку от ${callback()}.`);
// }

// makeMessage(customer.getFullName); // Будет ошибка при вызове функции

// ИНТЕРЕСНО
// Решение этой проблемы рассматривается в секции про метод bind() и методы объекта.

// ====================================================================
// this в стрелочных функциях

// Стрелочные функции не имеют своего this.В отличии от обычных функций,
// изменить значение this внутри стрелки после её объявления нельзя.

// ИНТЕРЕСНО
// Контекст внутри стрелки определяется местом её объявления, а не вызова и
// ссылается на контекст родительской функции.

// Стрелочные функции также игнорируют наличие строгого режима.Если стрелка
// запомнила глобальный контекст, то this в ней будет содержать ссылку на

// const showThis = () => {
//   console.log("this in showThis: ", this);
// };

// showThis(); // this in showThis: window

// const user = {
//   username: "Mango",
// };
// user.showContext = showThis;

// user.showContext(); // this in showThis: window


// Ограничивая стрелочные функции постоянным контекстом, JavaScript - движки
//  могут лучше их оптимизировать, в отличие от обычных функций, значение
// this которых может быть изменено.

// Пример не практичный, но отлично показывает как работает контекст для
// стрелок.Значение контекста берется из родительской области видимости.

// const hotel = {
//   username: "Resort hotel",
//   showThis() {
//     const foo = () => {
//       // Стрелки запоминают контекст во время объявления,
//       // из родительской области видимости
//       console.log("this in foo: ", this);
//     };

//     foo();
//     console.log("this in showThis: ", this);
//   },
// };

// hotel.showThis();
// this in foo: {username: 'Resort hotel', showThis: ƒ}
// this in showThis: {username: 'Resort hotel',showThis: ƒ}

// ====================================================================
// ЗАДАЧА
// Перед увольнением разработчик сломал исходный код управления аккаунтами
//  пользователей нашего сервиса доставки еды.Выполни рефакторинг методов
//  объекта customer, расставив отсутствующие this при обращении к свойствам
// объекта.

// После объявления объекта мы добавили вызовы методов в той последовательности
// , в которой твой код будут проверять тесты.Пожалуйста ничего там не меняй.
// const customer = {
//   username: "Mango",
//   balance: 24000,
//   discount: 0.1,
//   orders: ["Burger", "Pizza", "Salad"],
//   // Change code below this line
//   getBalance() {
//     return this.balance;
//   },
//   getDiscount() {
//     return this.discount;
//   },
//   setDiscount(value) {
//     this.discount = value;
//   },
//   getOrders() {
//     return this.orders;
//   },
//   addOrder(cost, order) {
//     this.balance -= cost - cost * this.discount;
//     this.orders.push(order);
//   },
//   // Change code above this line
// };

// customer.setDiscount(0.15);
// console.log(customer.getDiscount()); // 0.15
// customer.addOrder(5000, "Steak");
// console.log(customer.getBalance()); // 19750
// console.log(customer.getOrders()); // ["Burger", "Pizza", "Salad", "Steak"]


